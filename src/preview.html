<p>Though we’ve only just begun our dive into <em>Bananas, Lenses, Envelopes, and Barbed Wire</em>, the next natural step in understanding recursion schemes brings us outside its purview. We must turn our attention to a paper written seven years later—<a href="http://cs.ioc.ee/~tarmo/papers/inf99.pdf"><em>Primitive(Co)Recursion and Course-of-Value (Co)Iteration, Categorically</em></a>, by Tarmo Uustalu and Varmo Vene. <em>Primitive (Co)Recursion</em> explores and formalizes the definition of apomorphisms (introduced first by Meijer et. al, and which we discussed, briefly, in the <a href="http://blog.sumtypeofway.com/recursion-schemes-part-iii-folds-in-context/">previous installment</a>) and describes two new recursion schemes, the <em>histomorphism</em> and the <em>futumorphism</em>.</p>
<p><em>Primitive (Co)Recursion</em> is a wonderful and illuminating paper, but it is dense in its concepts for those unfamiliar with category theory, and uses the semi-scrutable bracket syntax introduced by <em>Bananas</em>. But there’s no need for alarm if category theory isn’t your cup of tea: Haskell allows us, once again, to express elegantly the new recursion schemes defined in <em>Primitive (Co)Recursion</em>. Guided by Uustalu and Vene’s work, we’ll derive these two new recursion schemes and explore their ways in which they simplify complicated folds and unfolds. Though these new morphisms are, definition-wise, simple variations on paramorphisms and apomorphisms, in practice they provide surprising power and clarity, as Uustalu and Vene assert:</p>
<blockquote>
<p><span>[</span>We<span>]</span> argue that even these schemes are helpful for a declaratively thinking programmer and program reasoner who loves languages of programming and program reasoning where programs and proofs of properties of programs are easy to write and read.</p>
</blockquote>
<p>That sure sounds like us. Let’s get going.</p>
<h3 id="a-brief-recap">A Brief Recap</h3>
<p>In our first entry, we defined <code>Term</code>, the fixed-point of a Haskell <code>Functor</code>, with an <code>In</code> constructor that wraps one level of a structure and an <code>out</code> destructor to perform the corresponding unwrap<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>.</p>
<pre><code>newtype Term f = In { out :: f (Term f) }</code></pre>
<p>Given an algebra — a folding function that collapses a Functor <code>f</code> containing <code>a</code>’s into a single <code>a</code>—</p>
<pre><code>type Algebra f a = f a -&gt; a</code></pre>
<p>we use the catamorphism <code>cata</code> to apply a leaf-to-root<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> fold over any recursively-defined data structure. <code>cata</code> travels to the most deeply-nested point in the data structure by <code>fmap</code>ing itself, recursively, into the next level of the stucture. When <code>fmap cata x</code> returns an unchanged <code>x</code>, we cease recursing (because we have hit the most-deeply-nested point); we can then begin constructing the return value by passing each node to the algebra, leaf-to-root, until all the recursive invocations have finished.</p>
<pre><code>cata :: (Functor f) =&gt; Algebra f a -&gt; a -&gt; Term f
cata f = out &gt;&gt;&gt; fmap (cata f) &gt;&gt;&gt; f</code></pre>
<p>But the catamorphism has its limits: as it is applied to each level of the structure, it can only examine the current carrier value from which it is building. Given the F-algebra <code>f a -&gt; a</code>, each of the structure’s children—the <code>a</code> values contained in the <code>f</code> container—has already been transformed, thus losing information about the original structure. To remedy this, we introduced <code>para</code>, the paramorphism, and an R-algebra to carry the original structure with the accumulator:</p>
<pre><code>type RAlgebra f a = f (Term f, a) -&gt; a

para :: Functor f =&gt; RAlgebra f a -&gt; Term f -&gt; a
para f = out &gt;&gt;&gt; fmap (id &amp;&amp;&amp; para f) &gt;&gt;&gt; f</code></pre>
<h3 id="running-a-course-with-histomorphisms">Running a Course with Histomorphisms</h3>
<p>Paramorphisms allow us, at each stage of the fold, to view the original structure of the examined node before the fold began. Though this is more powerful than the catamorphism, in many cases it does not go far enough: many useful functions are defined not just in terms of the original argument to the function, but in terms of previous computed values. The classic<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a> example is the Fibonacci function, the general case of which is defined in terms of two previous invocations:</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">fib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
fib <span class="dv">0</span> <span class="fu">=</span> <span class="dv">0</span>
fib <span class="dv">1</span> <span class="fu">=</span> <span class="dv">1</span>
fib n <span class="fu">=</span> fib (n<span class="fu">-</span><span class="dv">1</span>) <span class="fu">+</span> fib (n<span class="fu">-</span><span class="dv">2</span>)</code></pre></div>
<p>We could express this function using a catamorphism—though one of the carrier values (<code>fib (n-1)</code>) would be preserved, as the accumulator of our fold, we would need another explicit recursive call to <code>cata</code> to determine the historical value of <code>fib (n-2)</code>. This is a bummer, both in terms of efficiency—we’re recalculating values we’ve already calculated—and in terms of beauty: a function so fundamental as <code>fib</code> deserves a better implementation, especially given the expressive power of recursion schemes.</p>
<p>The imperative programmers among us will have a solution to this inefficiency: “iterate!”, they will yell, or perhaps they will clamor “introduce a cache!” in a great and terrible voice. And it’s true: we could compute <code>fib</code> with a for-loop or by memoizing the recursive call. But the former approach entails mutable state—a very big can of worms to open for such a simple problem—and the latter leaves us <a href="https://twitter.com/importantshock/status/241173326846898176">with two problems</a>. Uustalu and Vene’s histomorphism provides a way out: we will <em>preserve the history</em> of the values our fold computes, so that further recursive calls to compute past values become unnecessary. This style of recursion is called <em>course-of-value recursion</em>, since we record the <em>values</em> evaluated as our fold function <em>courses</em> through the structure.</p>
<p>Rather than operate on an <code>f a</code>, a data structure in the process of being folded, we’ll operate on a more sophisticated structure, so that the argument to our fold function contains the history of all applications of the fold itself. Instead of a just a carrier value <code>a</code>, our <code>f</code> will contain a carrier value and a recursive, unrollable record of past invocations, to wit:</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Attr</span> f a <span class="fu">=</span> <span class="dt">Attr</span>
              {<span class="ot"> attribute ::</span> a
              ,<span class="ot"> hole      ::</span> f (<span class="dt">Attr</span> f a)
              }</code></pre></div>
<p>We’ll call this <code>Attr</code>, since it’s an ‘attributed’ version of <code>Term</code>.</p>
<p>An <code>Attr f a</code> contains an <code>a</code>—a carrier value, storing the in-progress value of the fold—as well as a fixed-point value (analogous to <code>Term</code>) at each level of recursion. Thanks to the fixed-point <code>hole</code> within the <code>f</code>, further <code>Attr</code> items are preserved, each of which contains the shape of the folded functor <code>f</code>. And within the <code>f</code> there lie further <code>Attr</code> values, each of which contains a carrier value yielded by <em>their</em> application in their <code>attribute</code> slot. And those <code>Attr</code> values in turn contain further <code>hole</code>s, which contain the historical records pertaining to <em>their</em> childrens’ history, and so on and so forth until the bottom of the data structure has been reached. As such, the entire history of the fold is accessible to us: the <code>holes</code> preserve the shape of the data structure (which was lost during <code>cata</code>), and the <code>attribute</code> holds the record of applying the fold to each entity in said data structure.</p>
<p>We have a word for preserving a record of the past, of course—<em>history</em><a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a>. A fold operation that uses <code>Attr</code> to provide both an accumulator and a record of prior invocations is known as a <em>histomorphism</em>—a shape-changing (<em>morpho</em>) fold with access to its history (<em>histo</em>).</p>
<p>Let’s define the histomorphism. It will, like its cousins <code>cata</code> and <code>para</code>, use an algebra for its fold function. But unlike the F-algebra of <code>cata</code> or the R-algebra of <code>para</code>, we’ll be using an algebra that operates on an <code>Attr f a</code>, yielding an <code>a</code> out of it. We call this a course-of-value algebra, abbreviated to a <em>CV-algebra</em>, and define a type alias for it, so we end up with a more comprehensible type signature in the histomorphism:</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">CVAlgebra</span> f a <span class="fu">=</span> f (<span class="dt">Attr</span> f a) <span class="ot">-&gt;</span> a</code></pre></div>
<p>That is, a CV-algebra maps from a container <code>f</code> containing children of type <code>Attr f a</code> (which in turn contain <code>f (Attr f a)</code> children, as far down as is needed in the nested structure), to a final result type <code>a</code>. The shape of the folded structure and the history of its applications are all contained in its <code>Attr</code> values: all you have to do is unroll the <code>hole</code> value to go back one level in history and use <code>attribute</code> to examine the stored value.</p>
<p>Our <code>histo</code> function will be similar to <code>cata</code> and <code>para</code> at its heart. We start by unpacking the <code>Term</code>—the initial argument must be a <code>Term</code> rather than an <code>Attr</code>, since as we haven’t started the fold yet we have no value to fill in for <code>attribute</code>. We will then recurse, with <code>fmap</code>, into the thus-revealed structure until we hit its root. We then use the CV-algebra to build the value, starting at the root and continuing upwards to the topmost leaf. These steps are analogous to how we defined <code>cata</code> and <code>para</code>, so let’s start defining it:</p>
<pre><code>histo :: Functor f =&gt; CVAlgebra f a -&gt; Term f -&gt; a
histo h = out &gt;&gt;&gt; fmap worker &gt;&gt;&gt; h </code></pre>
<p>But what type should the worker have? Well, we can ask GHC, thanks to one of its most useful features<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a>—type holes. By prepending an underscore to the use of <code>worker</code>, we can allow the program compilation to continue as far as is possible—however, when the compilation process has finished, GHC will remind us where we used a type hole, and inform us of the type signature it inferred for <code>_worker</code>. (As a full-time Haskell programmer, I use this feature nearly every day.)</p>
<pre><code>histo :: Functor f =&gt; CVAlgebra f a -&gt; Term f -&gt; a
histo h = out &gt;&gt;&gt; fmap _worker &gt;&gt;&gt; h </code></pre>
<p>Running this code in GHC yields the following type-hole message:</p>
<pre><code>/Users/patrick/src/morphisms/src/Main.hs:14:24: error:
    • Found hole: ‘_worker’ with type :: Term f -&gt; Attr f a</code></pre>
<p>Okay, that makes sense! We’re operating on <code>Term f</code> values (lifted into this context by the <code>fmap</code> within <code>histo</code>), and we need to yield an <code>Attr f a</code>, so that the outside <code>Term f</code> can be transformed into an <code>f (Attr f a)</code> and then passed into the CV-algebra.</p>
<p>An <code>Attr f a</code>, as defined above, contains two values: a plain <code>a</code> type, and a recursive <code>f (Attr f a)</code> hole. Given a <code>Term f</code> and our ability to invoke both <code>histo</code> and <code>worker</code> recursively, we can build the <code>Attr f a</code> we need. Let’s start by defining the skeleton of <code>worker</code>: given a <code>Term f</code>, called <code>t</code>, it constructs an <code>Attr</code>, containing two fields.</p>
<pre><code>worker t = Attr _ _</code></pre>
<p>The first field, the <code>a</code>, is yielded by recursing with <code>histo</code> on the provided <code>Term</code>—easy enough. This is just like the catamorphism—indeed, a catamorphism is a histomorphism that ignores the provided history.</p>
<pre><code>worker t = Attr (histo h term) _</code></pre>
<p>The second field’s construction is more clever: we unwrap <code>term</code> with the <code>out</code> function, which gives us an <code>f (Term f)</code> out of a <code>Term f</code>. Since we don’t know exactly what type <code>f</code> is yet, we can’t extract the contained <code>Term f</code>—but we can operate on it, with <code>fmap</code>, provided by the <code>Functor</code> constraint. So, to go from an <code>f (Term f)</code> to an <code>f (Attr f a)</code>, we need a function of type <code>Term f -&gt; Attr f a</code>… hang on, that’s just <code>worker</code> itself!</p>
<pre><code>worker t = Attr (histo h term) (fmap worker (out t))</code></pre>
<p>This is the heart of <code>histo</code>‘s elegance: it’s ’doubly recursive’, in that its <code>worker</code> function invokes both <code>histo</code> and <code>worker</code> itself.</p>
<p>Now we have a <code>histo</code> function that passes the typechecker:</p>
<pre><code>histo :: Functor f =&gt; CVAlgebra f a -&gt; Term f -&gt; a
histo h = out &gt;&gt;&gt; fmap worker &gt;&gt;&gt; h where
    worker t = Attr (histo h t) (fmap worker (out t))</code></pre>
<p>However, this function does not share its subcomputations properly: each iteration of <code>worker</code> recomputes, rather than reuses, all the nested <code>hole</code> values within the constructed <code>Attr</code>. We can fix this by promoting <code>worker</code> to operate on <code>Attr</code> values; by recursing with <code>fmap worker</code>, placing the input and output of the CV-algebra in a tuple with <code>&amp;&amp;&amp;</code>, and then unpacking the tuple into an <code>Attr</code>, we ensure that all the constructed <code>Attr</code> values share their subcomputations.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">histo ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">CVAlgebra</span> f a <span class="ot">-&gt;</span> <span class="dt">Term</span> f <span class="ot">-&gt;</span> a
histo h <span class="fu">=</span> worker <span class="fu">&gt;&gt;&gt;</span> attribute <span class="kw">where</span>
  worker <span class="fu">=</span> out <span class="fu">&gt;&gt;&gt;</span> fmap worker <span class="fu">&gt;&gt;&gt;</span> (h <span class="fu">&amp;&amp;&amp;</span> id) <span class="fu">&gt;&gt;&gt;</span> mkAttr
  mkAttr (a, b) <span class="fu">=</span> <span class="dt">Attr</span> a b</code></pre></div>
<p>But what does this function <em>mean</em>? We’ve filled in all these type holes, and we have a working <code>histo</code> function, but why does it work? Why does this preserve the history?</p>
<p>The answer lies in <code>worker</code>, in the <code>id</code> function that captures and preserves the <code>Attr</code> the worker function is operating on. If we omitted that expression, we would have a function equivalent to <code>cata</code>—one that throws all its intermediate variables away while computing the result of a fold. But our worker function ensures that the result computed at each stage is not lost: as we flow, root-to-leaf, upwards through the data structure, we construct a new <code>Attr</code> value, which in turn contains the previous result, which itself preserves the result before that, and so on. Each step yields an up-to-date snapshot of what we have computed in the past.</p>
<p>By <em>not throwing out intermediate results</em>, and pairing these intermediate results with the values used to calculate them, we automatically generate <em>and update</em> a cache for our fold.</p>
<p>Now, I may have used <code>fib</code> as an example of a course-of-value recursive function, but I won’t provide an example of using <code>histo</code> to calculate the nth Fibonacci number (though it’s a good exercise). Let’s solve a toy problem that’s slightly more interesting, one that histomorphisms make clear and pure, and one whose solution can be generalized to all other problems of its ilk.</p>
<h2 id="c-c-c-changes">C-C-C-Changes</h2>
<p>The <a href="https://en.wikipedia.org/wiki/Change-making_problem">change-making problem</a> is simple: given a monetary amount <code>N</code>, and a set of denominations (penny, nickel, dime, &amp;c.), how many ways can you make change for <code>N</code>? While it’s possible to write a naïve recursive solution for this problem, it becomes intolerably slow for large values of <code>N</code>: each computation for <code>N</code> entails computing the values for <code>N - 1</code>, and <code>N - 2</code>, and <code>N - 3</code>, and so forth: if we don’t store these intermediate amounts in a cache, we will waste our precious time on this earth. And, though this era may be grim as all hell, slow algorithms are no way to pass the time.</p>
<p>We’ll start by setting up a list of standard denominations. Feel free to adjust this based on the denominational amounts of your country of residence.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Cent</span> <span class="fu">=</span> <span class="dt">Int</span>

<span class="ot">coins ::</span> [<span class="dt">Cent</span>]
coins <span class="fu">=</span> [<span class="dv">50</span>, <span class="dv">25</span>, <span class="dv">10</span>, <span class="dv">5</span>, <span class="dv">1</span>]</code></pre></div>
<p>So our fundamental procedure is a function <code>change</code>, that takes a cent amount and returns a count of how many ways we can make change for said cent amount:</p>
<pre><code>change :: Cent -&gt; Int</code></pre>
<p>It is here where we hit our first serious roadblock. I asserted earlier that the change-making problem, and all the other <a href="https://en.wikipedia.org/wiki/Knapsack_problem">knapsack problems</a> of its ilk, are soluble with a histomorphism—a cached fold over some sort of data structure. But here we’re dealing with… natural-number values. There are no lists, no vectors, no rose trees—nothing mappable (that is to say, nothing with a <code>Functor</code> instance) and therefore nothing to fold over. What are we supposed to do?</p>
<p>All is not lost: we can fold over the natural numbers, just as we would fold over a list. We just have to define the integers in an unconventional, but simple, way: every natural number is either zero, or 1 + the previous. We’ll call this formulation of the natural numbers <code>Nat</code>— the zero value will be <code>Zero</code><a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a>, and the notion of the subsequent number <code>Next</code>. Put another way, we need to encode <a href="https://en.wikipedia.org/wiki/Peano_axioms">Peano numerals</a> in Haskell<a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a>.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Nat</span> a
    <span class="fu">=</span> <span class="dt">Zero</span>
    <span class="fu">|</span> <span class="dt">Next</span> a
    <span class="kw">deriving</span> <span class="dt">Functor</span></code></pre></div>
<p>We use <code>Term</code> to parameterize <code>Nat</code> in terms of itself—that is to say, given <code>Term</code>, we can stuff a <code>Nat</code> into it so as to represent an arbitrarily-nested hierarchy of contained <code>Nat</code>s, and thus represent all the natural numbers:</p>
<pre><code>one, two, three :: Term Nat
one   = In (Next (In Zero))
two   = In (Next one)
three = In (Next two)</code></pre>
<p>For convenience’s sake, we’ll define functions that convert from standard <code>Int</code> values to foldable <code>Term Nat</code>s, and vice versa. Again, these do not look particularly efficient, but please give me the benefit of the doubt.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- Convert from a natural number to its foldable equivalent, and vice versa.</span>
<span class="ot">expand ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="dt">Nat</span>
expand <span class="dv">0</span> <span class="fu">=</span> <span class="dt">In</span> <span class="dt">Zero</span>
expand n <span class="fu">=</span> <span class="dt">In</span> (<span class="dt">Next</span> (expand (n <span class="fu">-</span> <span class="dv">1</span>)))

<span class="ot">compress ::</span> <span class="dt">Nat</span> (<span class="dt">Attr</span> <span class="dt">Nat</span> a) <span class="ot">-&gt;</span> <span class="dt">Int</span>
compress <span class="dt">Zero</span>              <span class="fu">=</span> <span class="dv">0</span>
compress (<span class="dt">Next</span> (<span class="dt">Attr</span> _ x)) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> compress x</code></pre></div>
<p>While this is, at a glance, obviously less-efficient than using integers, it’s not as bad as it seems. We only have three operations: increment, converting from zero, and converting to zero. Restricting our operations to these—rather than writing our own code for addition or subtraction, both of which are linear-time over the Peano numerals—means that operations on our <code>Term Nat</code> types are almost the same as hardware-time costs, barring GHC-specific operations. As such, the expressivity we yield with our foldable numbers is well worth the very slight costs.</p>
<p>Given an amount (<code>amt</code>), we solve the change-making problem by converting that amount to a <code>Term Nat</code> with <code>expand</code>, then invoking <code>histo</code> on it with a provided CV-algebra—let’s call it <code>go</code>. We’ll define it in a where-clause below.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">change ::</span> <span class="dt">Cent</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
change amt <span class="fu">=</span> histo go (expand amt) <span class="kw">where</span></code></pre></div>
<p>Since we’re operating on foldable natural values (<code>Nat</code>) and ultimately yielding an integral result (the number of ways it is possible to make change for a given <code>Nat</code>), we know that our CV-algebra will have as its carrier functor <code>Nat</code> and its result type <code>Int</code>.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">  <span class="co">-- equivalent to Nat (Attr Nat Int) -&gt; Int  </span>
<span class="ot">  go ::</span> <span class="dt">Nat</span> (<span class="dt">Attr</span> <span class="dt">Nat</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span></code></pre></div>
<p>Because <code>histo</code> applies its algebra from leaf-to-root, it starts at the deepest nested position in the <code>Term Nat</code>—that is to say, <code>Zero</code>. We know that there’s only one way to make change for zero coins—by giving zero coins back—so we encode our base case by explicitly matching on a Zero and returning 1.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">  go <span class="dt">Zero</span> <span class="fu">=</span> <span class="dv">1</span></code></pre></div>
<p>Now comes the interesting part—we have to match on <code>Next</code>. Contained in that <code>Next</code> value will be an <code>Attr Nat Int</code> (which we’ll refer to as <code>attr</code>), containing the value yielded from applying <code>go</code> to the previous <code>Nat</code>ural number. Since we’ll need to feed this function into <code>compress</code> to perform actual numeric operations on it (since we did not write the requisite boilerplate to make <code>Nat</code> an instance of the <code>Num</code> typeclass<a href="#fn8" class="footnoteRef" id="fnref8"><sup>8</sup></a>), we’ll use an @-pattern to capture it under the name <code>curr</code>.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">  go curr<span class="fu">@</span>(<span class="dt">Next</span> attr) <span class="fu">=</span> <span class="kw">let</span></code></pre></div>
<p>Because we need to find out what numeric amounts (from <code>coins</code>) are valid change-components for <code>curr</code>, we have to get an <code>Int</code> out of <code>curr</code>. We’ll call this value <code>given</code>, since it’s our given amount.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">    given               <span class="fu">=</span> compress curr</code></pre></div>
<p>Now we have to look at each value of the <code>coins</code> list. Any values greater than <code>given</code> are right out: you can’t use a quarter to make change for a dime, obviously.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">    validCoins          <span class="fu">=</span> filter (<span class="fu">&lt;=</span> given) coins</code></pre></div>
<p>Now we subtract the <code>given</code> amount from each element of <code>validCoins</code>. This list represents, for each coin in <code>validCoins</code>, how much change we have remaining after using that coin to make change for <code>given</code>—if <code>given</code> were equal to 10, the list would be <code>[9, 5, 0]</code>.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">    remaining           <span class="fu">=</span> map (given <span class="fu">-</span>) validCoins</code></pre></div>
<p>Now we partition this <code>remaining</code> list into two sublists: the items equal to zero and those that are not. We don’t need to consult the lookup table for the items that are zero, obviously, but we need to do so for the others.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">    (zeroes, toProcess) <span class="fu">=</span> partition (<span class="fu">==</span> <span class="dv">0</span>) remaining</code></pre></div>
<p>Given each number in <code>toProcess</code>, we have to consider how many ways we could make change out of that number—but, since we know that that we’ve already calculated that result, because it’s by definition less than <code>given</code>! So all we have to do is look up the cached result in our <code>attr</code>. (We’ll implement the <code>lookup</code> function later on—it is two lines of code.) We’ll add all these cached results together with <code>sum</code>.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">    results             <span class="fu">=</span> sum (map (lookup attr) toProcess)</code></pre></div>
<p>Then all that’s left to do is add <code>zeroCount</code> and <code>others</code> together.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">    <span class="kw">in</span> length zeroes <span class="fu">+</span> results</code></pre></div>
<p>Let’s take a look at what we’ve written so far.</p>
<pre><code>change :: Cent -&gt; Int
change amt = histo go (expand amt) where
  go :: Nat (Attr Nat Int) -&gt; Int
  go Zero = 1
  go curr@(Next attr) = let
    given               = compress curr
    validCoins          = filter (&lt;= given) coins
    remaining           = map (given -) validCoins
    (zeroes, toProcess) = partition (== 0) remaining
    results             = sum (map (lookup attr) toProcess)
    in length zeroes + results</code></pre>
<p>Wow. This is pretty incredible. Not only do we have a simple, pure, concise, and performant solution to the change-making problem, but the caching is <em>implicit</em>: we don’t have to update the cache ourselves, because <code>histo</code> does it for us. We’ve stripped away the artifacts required to solve this problem efficiently and zeroed in on the essence of the problem. This is remarkable.</p>
<p>I told you I would show you how to look up the cached values, and indeed I will do so now. An <code>Attr Nat a</code> is essentially a nonempty list: if we could pluck the most-final <code>Attr Nat a</code> after <code>change</code> has finished executing, we would see the value of <code>change 0</code> stored inside the first <code>attribute</code> value, the value of <code>change 1</code> stored inside the <code>attribute</code> within the first attribute’s <code>hole</code>, and the value for <code>change 2</code> inside that further <code>hole</code>. So, given an index parameter <code>n</code>, we return the <code>attribute</code> if <code>n</code> is 0, and we recurse inside the <code>hole</code> if not, with <code>n - 1</code>.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">lookup<span class="ot"> ::</span> <span class="dt">Attr</span> <span class="dt">Nat</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a
lookup cache <span class="dv">0</span> <span class="fu">=</span> attribute cache
lookup cache n <span class="fu">=</span> lookup inner (n <span class="fu">-</span> <span class="dv">1</span>) <span class="kw">where</span> (<span class="dt">Next</span> inner) <span class="fu">=</span> hole cache</code></pre></div>
<h2 id="a-shape-shifting-cache">A Shape-Shifting Cache</h2>
<p>Something crucial to note is that the fixed-point accumulator—the <code>f (Attr f a)</code> parameter to our CV-algebra—<em>changes shape</em> based on the functor <code>f</code> contained therein. Given an inductive functor <code>Nat</code> that defines the natural numbers, <code>Nat (Attr Nat a)</code> is isomorphic to <code>[]</code>, the ordinary linked list: a <code>Zero</code> is the empty list, and a <code>Next</code> that contains a value (stored in <code>Attr</code>’s <code>attribute</code> field) and a pointer to the next element of the list (stored in the <code>hole :: Nat (Attr Nat a))</code> field in the given <code>Attr</code>). This is why our implementation of <code>lookup</code> is isomorphic to an implementation of <code>!!</code> over <code>[]</code>—because they’re the same thing.</p>
<p>But what if we use a different <code>Functor</code> inside an <code>Attr</code>? Well, then the shape of the resulting <code>Attr</code> changes. If we provide the list type—<code>[]</code>—we yield <code>Attr [] a</code>, which is isomorphic to a rose tree—in Haskell terms, a <code>Tree a</code>. If we use <code>Either b</code>, then <code>Attr (Either b) a</code> is a nonempty list of computational steps, terminating in some <code>b</code> value. <code>Attr</code> is more than an “attributed <code>Term</code>”—it is an <em>adaptive cache</em> for a fold over <em>any type of data structure</em>. And that is truly wild.</p>
<h2 id="obsoleting-old-definitions">Obsoleting Old Definitions</h2>
<p>As with <code>para</code>, the increased power of <code>histo</code> allows us to express <code>cata</code> with new vocabulary. Every F-algebra can be converted into a CV-algebra—all that’s needed is to ignore the <code>hole</code> values in the contained Functor <code>f</code>. We do this by mapping <code>attribute</code> over the functor before passing it to the F-algebra, throwing away the history contained in <code>hole</code>.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">cata ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Algebra</span> f a <span class="ot">-&gt;</span> <span class="dt">Term</span> f <span class="ot">-&gt;</span> a
cata f <span class="fu">=</span> histo (fmap attribute <span class="fu">&gt;&gt;&gt;</span> f)</code></pre></div>
<p>Similarly, we can express <code>para</code> with <code>histo</code>, except instead of just fmapping with <code>attribute</code> we need to do a little syntactic juggling to convert an <code>f (Attr f a)</code> into an <code>f (Term f, a)</code>. (Such juggling is why papers tend to use banana-bracket notation: implementing this in an actual programming language often requires syntactic noise such as this.)</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">para ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">RAlgebra</span> f a <span class="ot">-&gt;</span> <span class="dt">Term</span> f <span class="ot">-&gt;</span> a
para f <span class="fu">=</span> histo (fmap worker <span class="fu">&gt;&gt;&gt;</span> f) <span class="kw">where</span>
  worker (<span class="dt">Attr</span> a h) <span class="fu">=</span> (<span class="dt">In</span> (fmap (worker <span class="fu">&gt;&gt;&gt;</span> fst) h), a)</code></pre></div>
<h2 id="controlling-the-future-with-futumorphisms">Controlling the Future with Futumorphisms</h2>
<p>Throughout this series, we can derive unfolds from a corresponding fold by “reversing the arrows”—viz., finding the function dual to the fold in question. And the same holds true for histomorphisms—the dual is very powerful. But, to find the dual of <code>histo</code>, we must first find the dual of <code>Attr</code>.</p>
<p>Whereas our <code>Attr</code> structure held both an <code>a</code> and a recursive <code>f (Attr f a)</code> structure, its dual—<code>CoAttr</code>—holds <em>either</em> an <code>a</code> value—we’ll call that <code>Automatic</code>—or a recursive <code>f (CoAttr f a)</code> value, which we’ll call <code>Manual</code>. (Put another way, since <code>Attr</code> was a product type, its dual is a sum type.) The definition follows:</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">CoAttr</span> f a
  <span class="fu">=</span> <span class="dt">Automatic</span> a
  <span class="fu">|</span> <span class="dt">Manual</span> (f (<span class="dt">CoAttr</span> f a))</code></pre></div>
<p>And the dual of a CV-algebra is a CV-coalgebra:</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">CVCoalgebra</span> f a <span class="fu">=</span> a <span class="ot">-&gt;</span> f (<span class="dt">CoAttr</span> f a)</code></pre></div>
<p>So why call these <code>Automatic</code> and <code>Manual</code>? It’s simple—returning a <code>Manual</code> value from our CV-coalgebra means that we specify manually how the unfold should proceed at this level, which allows us to unfold more than one level at a time into the future. By contrast, returning a <code>Automatic</code> value tells the unfold to continue automatically at this level. This is why we call them <em>futu</em>morphisms—our CV-coalgebra allows us to determine the <em>future</em> of the unfold. (The term ‘futumorphism’ is etymologically dubious, since the ‘futu-’ prefix is Latin and the ‘-morpho’ suffix is Greek, but there are many other examples of such dubious words: ‘television’, ‘automobile’, and ‘monolingual’, to name but a few.)</p>
<p>Like its predecessor unfolds <code>ana</code> and <code>apo</code>, the futumorphism will take a coalgebra, a seed value <code>a</code>, and produce a term <code>f</code>:</p>
<pre><code>futu :: Functor f =&gt; CVCoalgebra f a -&gt; a -&gt; Term f</code></pre>
<p>We derived the anamorphism and apomorphism by reversing the arrows in the definitions of <code>cata</code> and <code>para</code>. The same technique applies here—<code>&gt;&gt;&gt;</code> becomes <code>&lt;&lt;&lt;</code>, and <code>In</code> becomes <code>out</code>. And as previously, we use a type hole to derive the needed signature of the helper function.</p>
<pre><code>futu :: Functor f =&gt; CVCoalgebra f a -&gt; a -&gt; Term f
futu f = In &lt;&lt;&lt; fmap _worker &lt;&lt;&lt; f</code></pre>
<pre><code>/Users/patrick/src/morphisms/src/Main.hs:28:32: error:
    • Found hole: ‘_worker’ with type :: CoAttr f a -&gt; Term f</code></pre>
<p>This also makes sense! The worker function we used in <code>histo</code> was of type <code>Term f -&gt; Attr f a</code>—by reversing the arrows in this worker and changing <code>Attr</code> to <code>CoAttr</code>, we’ve derived the function we need to define <code>futu</code>. And its definition is straightforward:</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">futu ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">CVCoalgebra</span> f a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> f
futu f <span class="fu">=</span> <span class="dt">In</span> <span class="fu">&lt;&lt;&lt;</span> fmap worker <span class="fu">&lt;&lt;&lt;</span> f <span class="kw">where</span>
    worker (<span class="dt">Automatic</span> a) <span class="fu">=</span> futu f a        <span class="co">-- continue through this level</span>
    worker (<span class="dt">Manual</span> g) <span class="fu">=</span> <span class="dt">In</span> (fmap worker g) <span class="co">-- omit folding this level,</span>
                                           <span class="co">-- delegating to the worker</span>
                                           <span class="co">-- to perform any needed </span>
                                           <span class="co">-- unfolds later on.</span></code></pre></div>
<p>When we encounter a plain <code>Continue</code> value, we continue recursing into it, perpetuating the unfold operation. When we encounter a <code>Stop</code> value, we run one more iteration on the top layer of the in-progress fold (transforming its children from <code>Coattr f a</code> values into <code>Term f</code> values by recursively invoking <code>worker</code>), then wrap the whole item up with an <code>In</code> constructor and return a final value. The product of this nested invocation of <code>worker</code> is then similarly passed to the <code>In</code> constructor to wrap it up in a fixpoint, then returned as the final output value of <code>futu</code>.</p>
<p>What differentiates this from <code>apo</code>—which, if you recall, used an <code>Either</code> type to determine whether or not to continue the unfold—is that we can specify, <em>in each field of the functor f</em>, whether we want to continue the unfold or not. <code>apo</code> gave us a binary switch—either stop the unfold with a <code>Left</code> or keep going with a <code>Right</code>. <code>futu</code>, by contrast, lets us build out as many layers at a time as we desire, giving us the freedom to manually specify the shape of the structure or relegate its shape to future invocations of the unfold.</p>
<p>This is an interesting way to encode unfolds! A CV-coalgebra that always returns a <code>Continue</code> value will loop infinitely, such as the unfold that generates all natural numbers. This means that we can tell, visually, whether our unfold is infinite or terminating.</p>
<p>“But Patrick,” you might say, “this looks like a cellular automaton.” And you would be right—CV-coalgebras describe tree automata. And in turn, coalgebras describe finite-state automata, and R-coalgebras describe stream automata. We’ll use this fact to define an example CV-coalgebra, one that grows<a href="#fn9" class="footnoteRef" id="fnref9"><sup>9</sup></a> random plant life.</p>
<h3 id="horticulture-with-futumorphisms">Horticulture with Futumorphisms</h3>
<p>Let’s start by defining the various parts of a plant.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Plant</span> a
  <span class="fu">=</span> <span class="dt">Root</span> a     <span class="co">-- every plant starts here</span>
  <span class="fu">|</span> <span class="dt">Stalk</span> a    <span class="co">-- and continues upwards</span>
  <span class="fu">|</span> <span class="dt">Fork</span> a a a <span class="co">-- but can trifurcate at any moment</span>
  <span class="fu">|</span> <span class="dt">Bloom</span>      <span class="co">-- eventually terminating in a flower</span>
    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Functor</span>)</code></pre></div>
<p>Let’s define a few rules for how a plant is generated. (These should, as I mentioned above, remind us of the rules for tree automata.)</p>
<pre><code>1. Plants begin at the ground. 
2. Every plant has a maximum height of 10.
3. Plants choose randomly whether to fork, grow, or bloom.
4. Every fork will contain one immediate bloom and two further stems.</code></pre>
<p>Rather than using integers to decide what action to take, which can get obscure very quickly, let’s define another sum type, one that determines the next step in the growth of the plant.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Action</span>
  <span class="fu">=</span> <span class="dt">Flower</span>  <span class="co">-- stop growing now</span>
  <span class="fu">|</span> <span class="dt">Upwards</span> <span class="co">-- grow up with a Stalk</span>
  <span class="fu">|</span> <span class="dt">Branch</span>  <span class="co">-- grow up with a Fork</span></code></pre></div>
<p>Because we need to keep track of the total height and a random number generator to provide randomness, we’ll unfold using a data type containing an <code>Int</code> to track the height and a <code>StdGen</code> generator from <code>System.Random</code>.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Seed</span> <span class="fu">=</span> <span class="dt">Seed</span>
    {<span class="ot"> height ::</span> <span class="dt">Int</span>
    ,<span class="ot"> rng    ::</span> <span class="dt">Random.StdGen</span>
    }</code></pre></div>
<p>We’ll define a function <code>grow</code> that takes a seed and returns both an randomly-chosen action and two new seeds. We’ll generate an action by choosing a random number from 1 to 5: if it’s 1 then we’ll choose to <code>Flower</code>, if it’s 2 we’ll choose to <code>Branch</code>, and otherwise we’ll choose to grow <code>Upwards</code>. (Feel free to change these values around and see the difference in the generated plants.) The <code>Int</code> determining the height of the plant is incremented every time <code>grow</code> is called.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">grow ::</span> <span class="dt">Seed</span> <span class="ot">-&gt;</span> (<span class="dt">Action</span>, <span class="dt">Seed</span>, <span class="dt">Seed</span>)
grow seed<span class="fu">@</span>(<span class="dt">Seed</span> h rand) <span class="fu">=</span> (choose choice, left { height <span class="fu">=</span> h <span class="fu">+</span> <span class="dv">1</span>}, right { height <span class="fu">=</span> h <span class="fu">+</span> <span class="dv">1</span>})
  <span class="kw">where</span> (choice, _) <span class="fu">=</span> Random.randomR (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>, <span class="dv">5</span>) rand
        (leftR, rightR) <span class="fu">=</span> Random.split rand
        left <span class="fu">=</span> <span class="dt">Seed</span> h leftR
        right <span class="fu">=</span> <span class="dt">Seed</span> h rightR
        choose <span class="dv">1</span> <span class="fu">=</span> <span class="dt">Flower</span>
        choose <span class="dv">2</span> <span class="fu">=</span> <span class="dt">Branch</span>
        choose _ <span class="fu">=</span> <span class="dt">Upwards</span></code></pre></div>
<p>And now we’ll define a CV-coalgebra, one that takes a <code>Seed</code> and returns a <code>Plant</code> containing a <code>CoAttr</code> value.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">sow ::</span> <span class="dt">CVCoalgebra</span> <span class="dt">Plant</span> <span class="dt">Seed</span></code></pre></div>
<p>The definition falls out rather quickly. We’ll start by growing a new seed, then examining the current height of the plant:</p>
<p>And now we’ll define a CV-coalgebra, one that takes a <code>Seed</code> and returns a <code>Plant</code> containing a <code>CoAttr</code> value.</p>
<pre><code>sow :: CVCoalgebra Plant Seed</code></pre>
<p>The definition falls out rather quickly. We’ll start by growing a new seed, then examining the current height of the plant:</p>
<pre><code>sow seed =
  let (action, next) = grow seed
  in case (height seed) of</code></pre>
<p>Since we’ll start with a height value of 0, we’ll begin by generating a root (rule 1). Because we want to immediately continue onwards with the unfold, we pass a <code>Continue</code> into this <code>Root</code>, giving it the subsequent seed (so that we get a new RNG value).</p>
<pre><code>   0 -&gt; Root (Continue next)</code></pre>
<p>Rule 2 means that we must cap the height of the plant at 10. So let’s do that:</p>
<pre><code>   10 -&gt; Bloom</code></pre>
<p>Otherwise, the height is immaterial. We must consult the <code>action</code> variable to know what to do next.</p>
<pre><code>   _  -&gt; case action of</code></pre>
<p>If the action is to <code>Flower</code>, then we again return a <code>Bloom</code>.</p>
<pre><code>      Flower -&gt; Bloom</code></pre>
<p>If it’s to grow <code>Upwards</code>, then we return a <code>Stalk</code>, with a contained <code>Continue</code> value to continue our fold at the top of that <code>Stalk</code>:</p>
<pre><code>      Upwards -&gt; Stalk (Continue next)</code></pre>
<p>And now we handle the <code>Branch</code> case. Our rules dictate that one of the branches will stop immediately, and the other two will continue, after a given length of <code>Stalk</code>. So we return a <code>Fork</code> with one <code>Stop</code> and two <code>Continues</code>.</p>
<pre><code>      Branch  -&gt; Fork -- grow a stalk then continue the fold
                     (Stop (Stalk (Continue next)))
                     -- halt immediately
                     (Stop Bloom)
                      -- again, grow a stalk and continue
                     (Stop (Stalk (Continue next)))</code></pre>
<p>Note how, even though we specify the construction of a <code>Stalk</code> in the first and third slots, we allow the fold to <code>Continue</code> afterwards. This is the power of the futumorphism: we can choose the future of our folds, layer by layer. This is not possible with an anamorphism or apomorphism.</p>
<p>Here’s our full <code>sow</code> function, rewritten slightly to use one <code>case</code> statement:</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">sow seed <span class="fu">=</span>
  <span class="kw">let</span> (action, left, right) <span class="fu">=</span> grow seed
  <span class="kw">in</span> <span class="kw">case</span> (action, height seed) <span class="kw">of</span>
    (_, <span class="dv">0</span>)       <span class="ot">-&gt;</span> <span class="dt">Root</span> (<span class="dt">Automatic</span> left)
    (_, <span class="dv">10</span>)      <span class="ot">-&gt;</span> <span class="dt">Bloom</span>
    (<span class="dt">Flower</span>, _)  <span class="ot">-&gt;</span> <span class="dt">Bloom</span>
    (<span class="dt">Upwards</span>, _) <span class="ot">-&gt;</span> <span class="dt">Stalk</span> (<span class="dt">Automatic</span> right)
    (<span class="dt">Branch</span>, _)  <span class="ot">-&gt;</span> <span class="dt">Fork</span> (<span class="dt">Manual</span> (<span class="dt">Stalk</span> (<span class="dt">Automatic</span> left)))
                         (<span class="dt">Manual</span> <span class="dt">Bloom</span>)
                         (<span class="dt">Manual</span> (<span class="dt">Stalk</span> (<span class="dt">Automatic</span> right)))</code></pre></div>
<p>This is pretty remarkable. We’ve encoded a complex set of rules, one that involves both nondeterminism and strict layout requirements, into one CV-coalgebra, and it took just eleven lines of code. No mutable state is involved, no manual accumulation is required—the entire representation of this automaton can be reduced to one pure function.</p>
<p>Now, in our <code>main</code> function, we can grab an RNG from the global state, and call <code>futu</code> to generate a <code>Term Plant</code>.</p>
<pre><code>main :: IO ()
main = do
  rnd &lt;- newStdGen
  let ourPlant :: Term Plant
      ourPlant = futu sow (Seed 0 rnd)</code></pre>
<p>Using a rendering function (which I have omitted for brevity’s sake, though you can be assured that it is implemented using <code>cata</code> rather than explicit recursion), we can draw a picture of the plant we’ve just generated, with little flowers.</p>
<pre><code>⚘
| ⚘     ⚘          ⚘
|⚘|     |          |
└─┘     |         |
 |      |          |       ⚘
 |  ⚘   |          |       |
 └─────┘          |   ⚘   | 
    |              └──────┘ 
    |        ⚘        |
    └───────────────┘
             |
             _</code></pre>
<p>Admittedly, the vaguaries of <a href="https://en.wikipedia.org/wiki/Code_page_437">code page 437</a> leave us with a somewhat unaesthetic result—but a nicer representation of <code>Plant</code>, perhaps using <a href="https://hackage.haskell.org/package/gloss">gloss</a> or <a href="https://hackage.haskell.org/package/Rasterific">Rasterific</a>, is left as an exercise for the reader.</p>
<p>One final detail: just as we can use an apomorphism to express an anamorphism, we can express anamorphisms and apomorphisms with futumorphisms:</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">ana ::</span> (<span class="dt">Functor</span> f) <span class="ot">=&gt;</span> <span class="dt">Coalgebra</span> f a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> f
ana f <span class="fu">=</span> futu (fmap <span class="dt">Automatic</span> <span class="fu">&lt;&lt;&lt;</span> f)

<span class="ot">apo ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">RCoalgebra</span> f a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> f
apo f <span class="fu">=</span> futu (fmap (either termToCoattr <span class="dt">Automatic</span>) <span class="fu">&lt;&lt;&lt;</span> f)
  <span class="kw">where</span> termToCoattr <span class="fu">=</span> <span class="dt">Manual</span> <span class="fu">&lt;&lt;&lt;</span> fmap termToCoattr <span class="fu">&lt;&lt;&lt;</span> out</code></pre></div>
<h3 id="my-god-its-full-of-comonads">My God, It’s Full of Comonads</h3>
<p>Now we know what histomorphisms and futumorphisms are. Histomorphisms are folds that allow us to query any previous result we’ve computed, and futumorphisms are unfolds that allow us to determine the future course of the unfold, multiple levels at a time. But, as is so often the case with recursion schemes, these definitions touch on something deeper and more fundamental.</p>
<p>Here’s the kicker: our above <code>CoAttr</code> definition is equivalent to the <code>Free</code> monad, and <code>Attr</code> (being dual to <code>CoAttr</code>) is the <code>Cofree</code> comonad.</p>
<p>We usually represent <code>Free</code>, aka <code>CoAttr</code>, as two constructors, one for pure values and one for effectful, impure values:</p>
<pre><code>data Free f a
    = Pure a
    | Impure (f (Free f a))</code></pre>
<p>And we usually represent the cofree comonad with an infix constructor, since the cofree comonad is at its heart a glorified tuple:</p>
<pre><code>data Cofree f a = a :&lt; (f (Cofree f a))</code></pre>
<p>The various packages in the Haskell ecosystem implement <code>cata</code> and <code>para</code> in much the same way, but the same is not true of <code>histo</code> and <code>futu</code>. Edward Kmett’s <a href="https://hackage.haskell.org/package/recursion-schemes">recursion-schemes</a> package uses these definitions of <code>Free</code> and <code>Cofree</code> (from the <a href="https://hackage.haskell.org/package/free">free</a> package). <a href="https://hackage.haskell.org/package/fixplate"><code>fixplate</code></a> uses a different definition of <code>Attr</code>: rather than being a data type in and of itself, it is defined as a <code>Term</code> over a more-general <code>Ann</code> type. <a href="https://hackage.haskell.org/package/compdata"><code>compdata</code></a>’s is slightly more complicated, as it leverages other typeclasses <code>compdata</code> provides to define attributes on nodes, but is at its heart the same thing. Each is equivalent.</p>
<p>The free monad, and its cofree comonad dual, lie at the heart of some of the most fascinating constructions in functional programming. I have neither the space nor the qualifications to provide a meaningful explanation of them, but I can enthusiastically recommend <a href="https://twitter.com/GabrielG439">Gabriel Gonzales</a>’s blog post on <a href="http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html">free monads</a>, <a href="https://twitter.com/sigfpe">Dan Piponi</a>’s post on the <a href="http://blog.sigfpe.com/2014/05/cofree-meets-free.html">cofree comonad</a>, and (of course) Oleg Kiselyov’s <a href="http://okmij.org/ftp/Computation/free-monad.html">groundbreaking work</a> on the free and freer monads. But I think the fact that, as we explore as fundamental a construct as recursion, we encounter another similarly fundamental concept of the free monad, provide an argument for the beauty and unity of the category-theoretical approach to functional programming that is far more compelling than any I could ever make myself.</p>
<p>I’d like to thank Rob Rix, who was essential to this work’s completion, and Colin Barrett, who has been an invaluable resource on the many occasions when I find myself stuck. I’d also like to thank Manuel Chakaravarty, who has done this entire series a great favor in checking it for accuracy, and Jeanine Adkisson, who found some outrageous bugs in the provided futumorphism. Greg Pfiel, Scott Vokes, and Josh Bohde also provided valuable feedback on drafts of this post. Mark Needham, Ian Griffiths, and Bryan Grounds found important bugs in the first published version of this post; I owe them a debt of gratitude. Next time, we’ll explore one of the most compelling reasons to use recursion schemes—the laws that they follow—and after that, we’ll discuss the constructs derived from combining unfolds with folds: the hylomorphism and the chronomorphism.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Bob Harper, in <em>Practical Foundations for Programming Languages</em>, refers to <code>In</code> and <code>out</code> as “rolling” and “unrolling” operations. This is a useful visual metaphor: the progression <code>f (f (Term f)) -&gt; f (Term f) -&gt; Term f</code> indeed looks like a flat surface being rolled up, and its opposite <code>Term f -&gt; f (Term f) -&gt; f (f (Term f))</code> looks like the process of unrolling.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Rob Rix <a href="https://twitter.com/rob_rix/status/793430628637274112">points out</a> that, though catamorphisms are often described as “bottom-up”, this term is ambiguous: catamorphisms’ recursion occurs top-down, but the folded value is constructed bottom-up. I had never noticed this ambiguity before. (The words of Carroll come to mind: “‘When I use a word,’ Humpty Dumpty said, in rather a scornful tone, ‘it means just what I choose it to mean — neither more nor less.’”)<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Unfortunately, in this context I think “classic” can be read as “hackneyed and unhelpful”. I dislike using <code>fib()</code> to teach recursion schemes, as the resulting implementations are both more complicated than a straightforward implementation and in no way indicative of the power that recursion schemes bring to the table. Throughout this series, I’ve done my damnedest to pick interesting, beautiful examples, lest the reader end up with the gravely mistaken takeaway that recursion schemes aren’t useful for any real-world purpose.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>A word with a rich pedigree—most directly from the Greek ‘ἱστορία’, meaning <em>a narration of what has been learned</em>, which in turn descended from ‘ἱστορέω’, <em>to learn through research</em>, and in turn from ‘ἵστωρ’, meaning <em>the one who knows</em> or <em>the expert</em>— a term commensurate with the first histories being passed from person to person orally. And the Greek root ‘ἱστο’, according to the OED, can be translated as ‘web’: a suitable metaphor for the structural web of values that the <code>Attr</code> type generates and preserves.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>A feature taken wholesale, we must note, from dependently-typed languages like Agda and Idris.<a href="#fnref5">↩</a></p></li>
<li id="fn6"><p>Natch.<a href="#fnref6">↩</a></p></li>
<li id="fn7"><p>Keen-eyed readers will note that this data type is isomorphic to the <code>Maybe</code> type provided by the Prelude. We could’ve just used that, but I wanted to make the numeric nature of this structure as clear as possible.<a href="#fnref7">↩</a></p></li>
<li id="fn8"><p>There is no reason why we couldn’t do this—I just chose to omit it for the sake of brevity.<a href="#fnref8">↩</a></p></li>
<li id="fn9"><p>which brings an amusing literalism to the term ‘seed value’<a href="#fnref9">↩</a></p></li>
</ol>
</section>
